# 整体思路

## 系统和环境

操作系统：win10

JDK版本：1.8

项目管理工具：maven 3.0

IDE：IDEA 2020

数据库：MySQL 8.0

浏览器：Google Chrome

服务器架构：SSM、AJAX

## 项目功能

登录、注册、用户管理（密码、个人信息、头像收货地址）、购物车（展示、增加、删除）、订单模块、热销产品

## 数据种类

用户、商品、商品类别、收藏、订单、购物车、收货地址

## 开发思路

- 持久层：根据前端的设置，规划和配置SQL语句
- 业务层：核心功能控制、业务操作和异常处理
- 控制层：接收请求、处理响应

![image-20220420205042991](电脑商城.assets/image-20220420205042991.png)

# 搭建项目

1.项目名称：store	结构：com.lrc.store

新建`Spring Initializr`项目，构建一个基础的SpringBoot项目

2.导入基础jar包

```
javaweb
mybatis
mysqldriver
```

3.在properties中配置数据库连接源信息

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/store?useUnicode=true&\characterEncoding=utf-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=123456
```

4.创建数据库并测试连接

- （后端）在单元测试类中测试数据库连接是否可以正常加载，通过注入数据元信息，获取数据库连接对象的信息

```java
@Autowired
private DataSource dataSource;//注入数据元信息

@Test
void getConnection() throws SQLException {
    System.out.println(dataSource.getConnection());
}
//HikariProxyConnection@1290795133 wrapping com.mysql.cj.jdbc.ConnectionImpl@3238e2aa

//Hikari:数据库连接池，管理数据库的连接对象
```

- （前端）访问项目静态资源是否可以正常加载，resourses.static存储静态资源

![image-20220420212112816](电脑商城.assets/image-20220420212112816.png)

> 注意:
> IDEA对于JS代码的兼容性较差，js代码可能无法正常加载。
>
> 解决：
> 1.idea缓存清理
> 2.clear-instal
> 3.rebuild重新构建
> 4.重启idea和操作系统

5.数据库操作

```sql
# 用户表
uid INT AUTO_INCREMENT COMMENT '用户id',
username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名',
PASSWORD CHAR(32) NOT NULL COMMENT '密码',
salt CHAR(36) COMMENT '盐值',
phone VARCHAR(20) COMMENT '电话号码',
email VARCHAR(30) COMMENT '电子邮箱',
gender INT COMMENT '性别:0-女，1-男',
avatar VARCHAR(50) COMMENT '头像',
is_delete INT COMMENT '是否删除：0-未删除，1-已删除',
created_user VARCHAR(20) COMMENT '日志-创建人',
created_time DATETIME COMMENT '日志-创建时间',
modified_user VARCHAR(20) COMMENT '日志-最后修改执行人',
modified_time DATETIME COMMENT '日志-最后修改时间',

# 地址表
aid INT AUTO_INCREMENT COMMENT '收货地址id',
uid INT COMMENT '归属的用户id',
NAME VARCHAR(20) COMMENT '收货人姓名',
province_name VARCHAR(15) COMMENT '省-名称',
province_code CHAR(6) COMMENT '省-行政代号',
city_name VARCHAR(15) COMMENT '市-名称',
city_code CHAR(6) COMMENT '市-行政代号',
area_name VARCHAR(15) COMMENT '区-名称',
area_code CHAR(6) COMMENT '区-行政代号',
zip CHAR(6) COMMENT '邮政编码',
address VARCHAR(50) COMMENT '详细地址',
phone VARCHAR(20) COMMENT '手机',
tel VARCHAR(20) COMMENT '固话',
tag VARCHAR(6) COMMENT '标签',
is_default INT COMMENT '是否默认：0-不默认，1-默认',
created_user VARCHAR(20) COMMENT '创建人',
created_time DATETIME COMMENT '创建时间',
modified_user VARCHAR(20) COMMENT '修改人',
modified_time DATETIME COMMENT '修改时间',
```

# 用户注册

## 1.创建实体类

`BaseEntity`
实体类基类,由于用户和收货地址都有一些共同的属性（创建时间、创建者、修改时间、修改者）

`User`
用户实体类

## 2.持久层

基础sql语句：

```sql
# 注册需要插入数据
insert into t_user(除了uid以外的字段列表) values(匹配的值列表)

# 判断当前用户名是否已经存在
select * from t_user where username=?
```

1.创建UserMapper接口，创建接口对应的映射文件，遵循和接口名称保持一致即可，创建`UserMapper.xml`

2.将接口中的方法对应到SQL语句，用标签完成。

# 查漏补缺

## Serializable

**序列化接口**，一个类只有实现了Serializable接口，它的对象才能被序列化。

- 序列化：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。
- 把对象转换为字节序列的过程称为对象的**序列化**
  把字节序列恢复为对象的过程称为对象的**反序列化**

**应用场景：**

在定义**实体类**时，会选择继承Serializable接口。

当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，需要把对象进行序列化。Serializable存储对象在存储介质中，以便在下次使用的时候，可以很快捷的重建一个副本。

**Serializable接口内部是空的，相当于一个标识接口。用于通知JVM将相应的类做序列化。**

- **serialversionUID**

serialVersionUID是用来辅助对象的序列化与反序列化的，原则上序列化后的数据当中的serialVersionUID与当前类当中的serialVersionUID一致，那么该对象才能被反序列化成功。这个serialVersionUID的详细的工作机制是：在序列化的时候系统将serialVersionUID写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的serialVersionUID是否跟当前的文件的serialVersionUID是否一致，如果一直则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，

## @Data

`@Data`注解的主要作用是提高代码的简洁，使用这个注解可以省去代码中大量的`get()`、`set()`、`toString()`等方法

## DAO

用于持久层。负责与数据库联络的任务和方法都封装在此。

mapper层（即DAO层）：是对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，用mybatis逆向工程生成。

设计思想：
首先设计DAO接口，然后定义此接口的实现类。通过Spring注解或配置文件实现DAO模块的调用，进行数据业务处理。

> DAO设计模式优点
> （1）DAO模式抽象出数据访问方式，业务逻辑层访问数据源时完全感觉不到数据源的存在。软件工厂中有一条很重要的法则：一个对象对其他对象的了解越少越好，了解越少就意味着依赖越少，可复用性越高。
>
> （2）DAO将数据访问集中在独立的一层，因为所有的数据访问都由DAO代理，这层独立的DAO将数据访问的实现和系统的其余部分剥离，将数据访问集中，使得系统更具可维护性。
>
> （3）DAO降低了业务逻辑层的复杂度。DAO管理复杂的数据访问，从而简化了业务逻辑层。所有与数据访问的实现有关的代码都不写在业务逻辑层里，业务逻辑层可集中处理业务逻辑，提高了代码的可读性和生产率。
>
> （4）DAO有助于提升系统的可移植性。DAO模式通过将数据访问划分为抽象层和实现层，分离数据使用和数据访问的实现细节。这意味着业务层与数据访问的底层细节无关，也就是说，可以在保持上层机构不变的情况下，通过切换底层实现来修改数据访问的具体机制，提高了系统的可复用性。
