# 数据结构

## 稀疏数组

当数组中大部分元素为0或为同一个元素时，可用稀疏数组保存该数组

```txt
0	0	0	22	0	0	0	0	0	0	-1	
0	36	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	-62	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
3	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	98	0	0	0	
0	0	0	65	0	0	0	0	0	0	0
↓	↓	↓
11	11	7
0	3	22
0	10	-1
1	1	36
3	9	-62
7	0	3
9	7	98
10	3	65
```

**稀疏数组特点：**
1.三列；
2.第一行：行数、列数、非零元素个数；
3.其余各行：非零元素的行、列、值

## 队列

队列是有序列列表（数组或链表），遵循**先入先出**的原则

### 基础队列

头指针`front`：首元素的前一个位置。初始值-1
尾指针`rear`：尾元素的位置。初始值-1

存数据时`rear`动，取数据时`front`动

缺点：该队列只能按顺序存取一次，指针位置不会循环变化，不能复用

### 环形队列

首尾相连
1.`front`:指向队列的第一个元素，即`arr[front]`就是队列的第一个元素。初始值0
2.`rear`:指向队列末尾元素后一个位置，空出一个空间做为约定。初始值0
3.当队列满的条件:`(rear + 1) % maxSize = front`
4.对队列为空的条件:`rear == front`
5.当我们这样分析，队列中有效的数据的个数`(rear + maxSize - front) % maxSize`

## 链表

单链表：节点尾连接		next
双链表：节点首尾连接	pre、next

### 单链表

**核心：**节点类中必须有指向下一个节点的**next变量**,需要一个**指针temp**

**需注意**
1.代码顺序。顺序颠倒导致了死循环、空指针等问题
2.该单链表的前提是有一个永不赋值的头节点(空的头节点)
3.循环时，节点从前一个节点开始，实际上操作还是`temp.next`

### 双链表

基础是单链表

**需注意**
按排名添加节点时，根据定位后面有无节点分为两种情况：
1.若定位处后面无节点，则可以直接添加，2次连接，顺序无要求
2.若后面有节点，需要重新分配该处节点连接情况，4次连接，顺序是重点

### 约瑟夫问题

**Joseph Question**

n个人围坐一圈，约定编号为k 的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

通过**单向环形链表**模拟约瑟夫问题：
没有空的头节点,链表存储节点对象，该对象的属性只有`int no`

## 栈 Stack

栈( stack )是限定仅在表尾进行插入和删除操作的线性表

**先入后出。 出栈pop，入栈push**

```java
//实现
private int maxSize;
private int[] stack;
private int top = -1;//栈顶

public ArrayStack(int maxSize) {
    this.maxSize = maxSize;
    stack = new int[this.maxSize];//初始化栈数组
}
//栈满
public boolean isFull() {
    return top == maxSize - 1;
}
//栈空
public boolean isEmpty() {
    return top == -1;
}
```

# 算法

## 后缀表达式

- **前缀表达式：**从右到左扫描，先将所有数字压入堆栈。遇到运算符时，弹出栈顶的两个数，对栈顶元素和次顶元素进行运算，阱将结果入栈。重复上述过程直到算完。
  举例：`(3+4)×5-6 = - × + 3 4 5 6`
- **中缀表达式：**即人类便于理解的算法

- **后缀表达式：**从左到右扫描，数字和运算符一起扫描，遇到数字压入，遇到运算符则弹出栈顶两个数进行运算并入栈，重复上述过程直到算完。逆波兰表达式，即后缀表达式。
  举例：`(3+4)×5-6 = 3 4 + 5 × 6`

### 中缀表达式转后缀表达式

**步骤**

1. 初始化两个栈:运算符栈s1和储存中间结果的栈s2
2. 从左至右扫描中缀表达式;
3. 遇到操作数时，将其压s2;
   1. 遇到运算符时，比较其与s1栈顶运算符的优先级
      如果s1为空，或栈顶运算符为左括号“("，则直接将此运算符入栈;
      2.若优先级比栈顶运算符的高，也将运算符压入s13
      3.否则，将s1核顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较;
4. 遇到括号时:
   (1)如果是左括号“("，则直接压入s1
   (2)如果是右括号“)"，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
5. 重复步骤2至5，直到表达式的最右边
6. 将s1中剩余的运算符依次弹出并压入s2
7. 依次弹出s2中的元素并输出，结果的逆序脚为中缀表达式对应的后缀表达式

## 递归

当程序执行到一个方法时，就会开辟一个独立的空间
